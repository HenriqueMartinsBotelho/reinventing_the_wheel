# Sobre

Reinventar a roda em programação é frequentemente desencorajado em contextos profissionais devido a preocupações de eficiência, tempo e potenciais erros. No entanto, do ponto de vista do aprendizado, há vários benefícios em fazê-lo.

Quando aprendemos algo pela primeira vez, muitas vezes confiamos em abstrações ou ferramentas existentes para nos ajudar a alcançar nossos objetivos mais rapidamente. Estas abstrações são inestimáveis, pois nos permitem construir sobre o trabalho dos outros sem a necessidade de entender todos os detalhes por baixo do capô. No entanto, esta abordagem pode, às vezes, criar lacunas no nosso entendimento ou dar-nos uma compreensão superficial de um conceito.

Aqui estão algumas razões pelas quais isso é benéfico:

Entendimento Fundamental: Criar algo do zero força o entendimento de cada detalhe e nuance.

Desenvolvimento de Habilidades de Resolução de Problemas: Resolver desafios inerentes à criação de algo novo ajuda a aprimorar habilidades de pensamento crítico e resolução de problemas.

Estímulo à Criatividade: Reinventar a roda permite a experimentação. Ao tentar construir algo já existente, podemos encontrar novas e inovadoras maneiras de abordar um problema.

Confiança e Autossuficiência: Superar os desafios de criar algo do zero pode ser extremamente gratificante e aumentar a confiança em suas habilidades.

# Lista de coisas para reinventar

1. [x] Servidores Web: Criar um servidor web personalizado quando servidores como Apache, Nginx, Tomcat ou servidores embutidos em frameworks, como o servidor de desenvolvimento do Express ou Django, estão disponíveis e são amplamente testados.

1. [ ] Sistemas de Gerenciamento de Banco de Dados (DBMS): Em vez de usar um DBMS estabelecido como PostgreSQL, MySQL ou MongoDB, um desenvolvedor decide criar seu próprio sistema do zero.

1. [ ] Virtual DOM: Criar um sistema de Virtual DOM personalizado em vez de usar soluções estabelecidas como React, Vue ou Svelte.

1. [ ] Transpiladores: Criar um transpilador personalizado para converter código de uma linguagem de programação para outra, em vez de usar soluções estabelecidas como Babel ou TypeScript.

1. [ ] Sistemas de Autenticação: Criar um sistema de autenticação do zero quando existem soluções como OAuth, JWT e bibliotecas que facilitam esse processo.

1. [ ] Frameworks Web: Escrever um novo framework web completo em vez de usar frameworks populares e testados como Django, Flask, Express ou Ruby on Rails.

1. [ ] Criptografia: Tentar implementar seus próprios algoritmos de criptografia em vez de usar padrões estabelecidos e testados, como AES ou RSA.

1. [ ] Bibliotecas de Manipulação de Data e Hora: Desenvolver sua própria lógica para lidar com datas e horas, em vez de usar bibliotecas como datetime ou moment.js.

1. [ ] Sistemas de Controle de Versão: Criar um novo sistema de controle de versão em vez de usar soluções estabelecidas como Git ou SVN.

1. [ ] Protocolos de Comunicação: Desenvolver um novo protocolo de comunicação em vez de usar padrões como HTTP, WebSocket ou MQTT.

1. [ ] Motor de Renderização Gráfica: Tentar escrever um motor de renderização gráfica do zero, em vez de usar soluções como OpenGL, Vulkan ou Direct3D.

1. [ ] Ferramentas de Build e Empacotamento: Criar sistemas personalizados de compilação e empacotamento quando ferramentas como Webpack, Rollup ou Gradle já oferecem soluções amplamente aceitas.

1. [ ] Teste Unitário: Desenvolver um framework de teste unitário do zero quando ferramentas como JUnit, NUnit, Mocha ou PyTest já existem e são amplamente aceitas pela comunidade.

1. [ ] ORM (Object-Relational Mapping): Escrever um ORM do zero em vez de usar soluções estabelecidas como Hibernate, SQLAlchemy ou Entity Framework.

1. [ ] Sistemas de Cache: Criar um sistema de cache personalizado quando soluções como Redis, Memcached ou ferramentas de cache local estão disponíveis.

1. [ ] Manipulação de Strings: Implementar funções personalizadas para manipulação de strings quando a maioria das linguagens de programação já oferece uma vasta biblioteca padrão para essas tarefas.

1. [ ] Parsers de XML/JSON: Escrever parsers personalizados para XML ou JSON em vez de usar bibliotecas robustas e eficientes que já existem, como xml.etree em Python ou JSON.parse() em JavaScript.

1. [ ] Sistemas de Logging: Desenvolver um sistema de registro (logging) personalizado em vez de usar frameworks como Log4j, SLF4J ou Winston.

1. [ ] Bibliotecas de Matemática e Estatística: Criar funções matemáticas ou estatísticas do zero quando bibliotecas como NumPy, SciPy ou MathJS já fornecem uma ampla variedade de funções otimizadas.

1. [ ] Bibliotecas de Concorrência e Paralelismo: Desenvolver soluções personalizadas para multitarefa e paralelismo quando linguagens modernas muitas vezes já possuem bibliotecas ou módulos dedicados, como asyncio em Python ou TPL em C#.

1. [ ] Motores de Busca de Texto: Implementar um motor de busca de texto completo do zero em vez de utilizar soluções estabelecidas como Elasticsearch ou Apache Solr.

1. [ ] Gerenciadores de Pacotes: Desenvolver um gerenciador de pacotes do zero, em vez de usar soluções populares como npm, pip, Maven ou Gem.

1. [ ] Sistemas de Filas de Mensagens: Criar um sistema de filas de mensagens personalizado, em vez de usar soluções estabelecidas como RabbitMQ, Kafka ou SQS.

1. [ ] Motores de Jogos: Tentar desenvolver um motor de jogo do zero, ao invés de utilizar motores já consolidados como Unity, Unreal Engine ou Godot.

1. [ ] Sistemas de Templates: Criar um sistema de templates personalizado para renderização de páginas web, ao invés de usar soluções como Handlebars, Jinja2 ou ERB.

1. [ ] Bibliotecas de Animação: Desenvolver uma biblioteca de animação do zero em vez de usar bibliotecas como GreenSock, Three.js ou A-Frame para animações na web.

1. [ ] Sistemas Operacionais: Embora seja um projeto enorme, construir um sistema operacional simples do zero, ao invés de usar Linux, Windows ou MacOS, pode ser um grande aprendizado.

1. [ ] Plataformas de Cloud: Tentar desenvolver uma plataforma simples de hospedagem na nuvem, semelhante a AWS, Google Cloud ou Azure, para entender os desafios por trás da computação em nuvem.

1. [ ] Sistemas de Arquivos: Desenvolver um sistema de arquivos personalizado, entendendo as nuances por trás da gestão e armazenamento de dados em dispositivos de armazenamento.

1. [ ] Linguagens de Programação: Criar uma linguagem de programação simples com seu próprio lexer, parser e compilador/interpretador. Esse é um desafio enorme, mas oferece insights profundos sobre como as linguagens de programação funcionam.

1. [ ] Bibliotecas de Rede: Desenvolver bibliotecas personalizadas para comunicação em rede, em vez de confiar em bibliotecas padrão ou frameworks para lidar com sockets, HTTP ou outros protocolos de comunicação.

## Livros

Livros que podem ajudar a entender como funcionam alguns dos sistemas acima:

500 Lines or Less
The Architecture of Open Source Applications
